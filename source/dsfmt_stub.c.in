#define DSFMT_DO_NOT_USE_OLD_NAMES
#define DSFMT_MEXP ${DSFMT_MEXP}

#include "unexport.h"
#include "dSFMT.c"

#include <caml/alloc.h>
#include <caml/custom.h>
#include <caml/fail.h>
#include <caml/memory.h>

#define STRINGIFY(S) #S

static inline dsfmt_t **pdsfmt_val(value x)
{
	return Data_custom_val(x);
}

static void finalize_dsfmt(value x)
{
	free(*pdsfmt_val(x));
}

static struct custom_operations dsfmt_ops = {
	.identifier = "jp.halfmoon.panathenaia.mt.dsfmt_" STRINGIFY(SFMT_MEXP),
	.finalize = finalize_dsfmt,
	.compare = custom_compare_default,
	.hash = custom_hash_default,
	.serialize = custom_serialize_default,
	.deserialize = custom_deserialize_default,
	.compare_ext = custom_compare_ext_default,
	.fixed_length = custom_fixed_length_default};

static value alloc_dsfmt(void)
{
	CAMLparam0();
	CAMLlocal1(val_result);
	val_result =
		caml_alloc_custom_mem(&dsfmt_ops, sizeof(void *), sizeof(dsfmt_t));
	dsfmt_t **result = pdsfmt_val(val_result);
	int error = posix_memalign((void **)result, 16, sizeof(dsfmt_t));
	if(error){
		*result = NULL;
		caml_raise_out_of_memory();
	}
	CAMLreturn(val_result);
}

#define CAT4(NAME1, NAME2, NAME3, NAME4) NAME1##NAME2##NAME3##NAME4
#define ENTRY(NAME1, NAME2, NAME3) CAT4(mlmt_, NAME1, NAME2, NAME3)

CAMLprim value ENTRY(dsfmt_, DSFMT_MEXP, _get_id_string)(value val_unit)
{
	CAMLparam1(val_unit);
	CAMLlocal1(val_result);
	val_result = caml_copy_string(dsfmt_get_idstring());
	CAMLreturn(val_result);
}

CAMLprim value ENTRY(dsfmt_, DSFMT_MEXP, _make_int32)(value val_seed)
{
	CAMLparam1(val_seed);
	CAMLlocal1(val_result);
	val_result = alloc_dsfmt();
	dsfmt_init_gen_rand(*pdsfmt_val(val_result), Int32_val(val_seed));
	CAMLreturn(val_result);
}

CAMLprim value ENTRY(dsfmt_, DSFMT_MEXP, _make_int32_array)(value val_seed)
{
	CAMLparam1(val_seed); /* int32 array */
	CAMLlocal1(val_result);
	val_result = alloc_dsfmt();
	size_t key_length = caml_array_length(val_seed);
	uint32_t init_key[key_length];
	for(size_t i = 0; i < key_length; ++i){
		init_key[i] = Int32_val(Field(val_seed, i));
	}
	dsfmt_init_by_array(*pdsfmt_val(val_result), init_key, key_length);
	CAMLreturn(val_result);
}

CAMLprim value ENTRY(dsfmt_, DSFMT_MEXP, _float_bits52)(value val_state)
{
	CAMLparam1(val_state);
	CAMLlocal1(val_result);
	val_result =
		caml_copy_double(dsfmt_genrand_close_open(*pdsfmt_val(val_state)));
	CAMLreturn(val_result);
}

CAMLprim value ENTRY(dsfmt_, DSFMT_MEXP, _unsafe_fill_floatarray52)(
	value val_state, value val_data, value val_pos, value val_len)
{
	CAMLparam4(val_state, val_data, val_pos, val_len);
	dsfmt_t *state = *pdsfmt_val(val_state);
	if(state->idx != DSFMT_N64) caml_failwith(__FUNCTION__);
	long len = Long_val(val_len);
	long pos = Long_val(val_pos);
	double *p = &Double_flat_field(val_data, pos);
	if(((uintptr_t)p & 15) == 0){
		dsfmt_fill_array_close_open(state, p, len);
	}else{
		_Alignas(16) double array[len];
		dsfmt_fill_array_close_open(state, array, len);
		for(size_t i = 0; i < (size_t)len; ++i){
			Store_double_flat_field(val_data, pos + i, array[i]);
		}
	}
	CAMLreturn(Val_unit);
}
